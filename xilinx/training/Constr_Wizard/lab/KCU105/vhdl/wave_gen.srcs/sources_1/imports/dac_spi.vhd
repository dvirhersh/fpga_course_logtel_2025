--<insert: c:\HW\releasedULD\headers\DAC_SPI.head>
-- -----------------------------------------------------------------------------
--
-- module:    DAC_SPI
-- project:   wave_gen
-- company:   Xilinx, Inc.
-- author:    WK, AW
-- 
-- comment:
--   This module takes each sample generated by the sample generator  and
--   sends it to the digital to analog converter (DAC) using the  SPI
--   protocol. Each SPI cycle is 32 clocks long, consisting of an  address,
--   command, and 16 bits of data (MSbit first). The DAC on the  development
--   boards use only the most significant 12 out of the 16 bit samples,  but
--   all 16 bits are transmitted.
-- 
-- known issues:
-- status           id     found     description                      by fixed date  by    comment
-- 
-- version history:
--   version    date    author     description
--    11.1-001 20 APR 2009 WK       New for version 11.1            
-- 
-- -----------------------------------------------------------------------
-- 
-- 
--<copyright-disclaimer-start>
--  ************************************************************************************************************
--  * Â© Copyright 2009-2022 Xilinx, Inc. All rights reserved.                                                  *
--  * This file contains confidential and proprietary information of Xilinx, Inc. and                          *
--  * is protected under U.S. and international copyright and other intellectual property laws.                *
--  * DISCLAIMER                                                                                               *
--  * This disclaimer is not a license and does not grant any rights to the materials distributed              *
--  * herewith. Except as otherwise provided in a valid license issued to you by Xilinx, and to the            *
--  * maximum extent permitted by applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS"               *
--  * AND WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,                 *
--  * IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT,     *
--  * OR FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable (whether in contract or tort,  *
--  * including negligence, or under any other theory of liability) for any loss or damage of any kind or      *
--  * nature related to, arising under or in connection with these materials, including for any direct, or     *
--  * any indirect, special, incidental, or consequential loss or damage (including loss of data, profits,     *
--  * goodwill, or any type of loss or damage suffered as a result of any action brought by a third party)     *
--  * even if such damage or loss was reasonably foreseeable or Xilinx had been advised of the possibility     *
--  * of the same.                                                                                             *
--  * CRITICAL APPLICATIONS                                                                                    *
--  * Xilinx products are not designed or intended to be fail-safe, or for use in any application requiring    *
--  * fail-safe performance, such as life-support or safety devices or systems, Class III medical devices,     *
--  * nuclear facilities, applications related to the deployment of airbags, or any other applications that    *
--  * could lead to death, personal injury, or severe property or environmental damage (individually and       *
--  * collectively, "Critical Applications"). Customer assumes the sole risk and liability of any use of       *
--  * Xilinx products in Critical Applications, subject only to applicable laws and regulations governing      *
--  * limitations on product liability.                                                                        *
--  * THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.                 *
--  *                                                                                                          *
--  ************************************************************************************************************
--<copyright-disclaimer-end>
--
-- -----------------------------------------------------------------------
--

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

library work;
use work.wave_gen_pkg.all;


entity DAC_SPI is
    Port (clk_tx         : in  std_logic;                    -- transmitter clock
          rst_clk_tx     : in  std_logic;                    -- reset signal synchronized to clk_tx
          en_clk_samp    : in  std_logic;                    -- indication that the next rising edge of clk_tx will coincide with the rising edge of clk_smap
          samp           : in  std_logic_vector(15 downto 0);-- the current sample being output. Only valid when samp_val is asserted
          samp_val       : in  std_logic;                    -- a vaild sample is being output. Asserted for one clk_samp period for each sample
          SPI_ss_b_o     : out std_logic;                    -- SPI serial flash chip select - tied to 1 (disabled)
          spi_clk_o      : out std_logic;                    -- SPI clock
          spi_mosi_o     : out std_logic;                    -- SPI master-out-slave-in datum
          DAC_cs_n_o     : out std_logic;                    -- DAC SPI chip select (active low)
          DAC_clr_n_o    : out std_logic                     -- DAC clear (active low)
          );
end DAC_SPI;


architecture Behavioral of DAC_SPI is

       signal data_to_send     : std_logic_vector(31 downto 0) := (others=>'U');
       signal start_spi        : std_logic := 'U';
       signal active           : std_logic := 'U';
       signal old_active       : std_logic := 'U';
       signal old_old_active   : std_logic := 'U';
       signal stretched_active : std_logic := 'U';
       signal spi_mosi         : std_logic := 'U';
       signal dac_cs_n         : std_logic := 'U';

    begin
    
       -- Generate dac_clr_n - asserted only when internal reset is asserted
       DACrst: process (clk_tx)
          begin
             if rising_edge(clk_tx) then                  -- process occurs synchonously with the tx clock
                if (rst_clk_tx = '1') then                -- has the internal reset been asserted?
                   dac_clr_n_o <= '0';                    -- active low assertion of reset
                else                                      -- do non-reset activities
                   dac_clr_n_o <= '1';                    -- no reset applied
                end if;                                   -- end of reset/non-reset activities
             end if;                                      -- end of synchronous events
          end process DACrst;
          
       -- capture the sample to send  [Write to an Update (Power Up) ch, N + channel A]
        data_to_send <= X"0030" &  samp;                  -- The sample to send
       
       -- when the new sample is captured, start the spi transfer on the next clk_samp
       start_spi <= samp_val and en_clk_samp;
          
       -- generate the serialized outputs
       genSerOut: process (clk_tx)
             variable bit_cnt     : integer range 0 to 32 := 0;
          begin
             if rising_edge(clk_tx) then                  -- this process runs synchronously to the tx clock
                if (rst_clk_tx = '1') then                -- is there a reset in progress?
                   active         <= '0';
                   old_active     <= '0';
                   old_old_active <= '0';
                   bit_cnt        := 0;
                   dac_cs_n       <= '1';                 -- keep DAC unselected (active low signal)
                   spi_mosi       <= '1';                 -- line idle high                
                else                                      -- no reset, do "normal" events
                   old_active     <= active;              -- one clock to account for pipeline delay of output
                   old_old_active <= old_active;          -- hold the last value for an extra clock
                   if (active = '0') then                 -- if we're currently not active then
                      dac_cs_n    <= '1';                 -- DAC normally disabled
                      spi_mosi    <= '1';                 -- line normally idles high
                      if (start_spi = '1') then           -- has there been a request to start an SPI transfer?
                         active <= '1';                   -- set flag indicating that we're actively in SPI transfer
                         dac_cs_n   <= '0';               -- select the DAC (active low)
                         spi_mosi   <= data_to_send(31);  -- send the first bit of the sequence
                         bit_cnt    := 30;                -- 32 bits to send, but we just sent one
                      end if;                             -- end of start SPI request test
                   else                                   -- we are active
                      spi_mosi   <= data_to_send(bit_cnt);-- send the next bit
                      if (bit_cnt = 0) then               -- did we just send the last bit?
                         active <= '0';                   -- indicate to the other processes that we're done sending
                      else                                -- still in the process of sending
                         bit_cnt := bit_cnt - 1;          -- count the bit that was just sent
                      end if;                             -- end of bit count check
                   end if;                                -- end of active tests
                end if;                                   -- end reset test 
             end if;                                      -- end synchronous events
          end process genSerOut;     

       -- Pipeline the outputs to ensure the can be pushed into the IOBs
       pipeSerOut: process (clk_tx)
          begin
             if rising_edge(clk_tx) then                  -- this process runs synchronously to the tx clock
                if (rst_clk_tx = '1') then                -- is there a reset in progress?
                  spi_mosi_o     <= '0';
                  dac_cs_n_o     <= '1';
                else
                  spi_mosi_o     <= spi_mosi;
                  dac_cs_n_o     <= dac_cs_n;
                end if;
              end if;
            end process pipeSerOut;
    
      -- Generate the SPI clock using the DDR flop
      -- Use old_active due to the pipelining of the output data, and stretch it by 
      -- one clock using old_old_active
      stretched_active <= old_active or old_old_active;
      out_ddr_flop_spi_clk_i0: out_ddr_flop  
          port map(clk    => clk_tx,
                   rst    => '0',
                   d_rise => vcc(0),
                   d_fall => stretched_active,
                   q         => spi_clk_o);
                   
      SPI_ss_b_o    <= '1';

    end Behavioral;

